# Additional Artifact Description

## File organization

### Solvers
We have bundled the following solvers with the artifact:
- Boolector (version 3.2.1 with CaDiCaL backend) at `/opt/boolector/3.2.1-cadical/bin/boolector` in the docker image
- z3 (version 4.8.8) at `/opt/z3/4.8.8/bin/z3` in the docker image

They are **not** available through the `PATH` variable.

For Rosette, they are symlinked to `/workspace/leanette-popl22-artifact/rosette-*/rosette/bin/`.
The Rosette program will use the solver specified in that directory.

For Grisette, the programs would try to find the solvers in the `PATH` variable,
so you need to prepend `/workspace/grisette-haskell-legacy/scripts/solvers` to the `PATH` variable when you run a program, for example, under the `grisette-haskell-legacy` directory:

```haskell
$ PATH="scripts/solvers:$PATH" stack run sanity-check
```

There are two solver wrappers in the `scripts/solverwrappers` directory.
These wrappers are used to collect the term sizes by recording the inputs to the solvers to a file.

### Scripts
There are several scripts in the `grisette-haskell-legacy/scripts` directory.

`runsinglebench.sh` runs a single benchmark.

The following script collects the timings for `cosette`:

```bash
$ ./runsinglebench.sh cosette
```

The following script collects the term count for `bonsai-nanoscala`:

```bash
$ ./runsinglebench.sh -t bonsai-nanoscala
```

These scripts has hardcoded the locations of the solvers so you do not need to specify them using the `PATH` variable.


`runallbench.sh` uses `runsinglebench.sh` to run a set of benchmarks and output a CSV to the terminal:

The following script runs `cosette` and `fluidics` for Grisette:

```bash
$ ./runallbench.sh cosette fluidics
```

The following script runs all available benchmarks for Grisette:

```bash
$ ./runallbench.sh all
```

The following script runs all benchmarks for Grisette (MEG):
```bash
$ ./runallbench.sh --unordered all
```

`report.py` uses `runallbench.sh` to run all the benchmarks for Grisette and Grisette (MEG), reads the CSV outputs from it, in addition to the CSV files generated by leanette's artifact.

```bash
$ ./report.py --r3 ../../leanette-popl22-artifact/perf/r3.csv --r4 ../../leanette-popl22-artifact/perf/r4.csv
```

The script would cache the CSV outputs from `runallbench.sh` to the filesystem.
To force rerun everything, you can add the `--rerun` flag.

```bash
$ ./report.py --rerun --r3 ../../leanette-popl22-artifact/perf/r3.csv --r4 ../../leanette-popl22-artifact/perf/r4.csv
```

### Packages

There are several Haskell packages in the [grisette-haskell-legacy](grisette-haskell-legacy) directory.

#### `grisette-core` 
The [grisette-core](grisette-haskell-legacy/grisette-core) package contains the core constructs for Grisette.
The implementation of the Union data structure is at
[UnionBase.hs](grisette-haskell-legacy/grisette-core/src/Grisette/Core/Data/UnionBase.hs).
This data structure is more general than the version discussed in the paper,
with the symbolic boolean type configurable.


[UnionMBase.hs](grisette-haskell-legacy/grisette-core/src/Grisette/Core/Control/Monad/UnionMBase.hs) contains the `UnionM` (actually more general `UnionMBase`) monad from the paper.

The various type classes supporting symbolic compilation is implemented at [](grisette-haskell-legacy/grisette-core/src/Grisette/Core/Data/Class).
- [BitVector.hs](grisette-haskell-legacy/grisette-core/src/Grisette/Core/Data/Class/BitVector.hs), [Bool.hs](grisette-haskell-legacy/grisette-core/src/Grisette/Core/Data/Class/Bool.hs), [Integer.hs](grisette-haskell-legacy/grisette-core/src/Grisette/Core/Data/Class/Integer.hs). [Function.hs](grisette-haskell-legacy/grisette-core/src/Grisette/Core/Data/Class/Function.hs) are aggregated constraints for the various symbolic primitives.
- [Error.hs](grisette-haskell-legacy/grisette-core/src/Grisette/Core/Data/Class/Error.hs) contains helpers for error handling.
- [Evaluate.hs](grisette-haskell-legacy/grisette-core/src/Grisette/Core/Data/Class/Evaluate.hs) is for evaluation given satisfiable solutions.
- [Mergeable.hs](grisette-haskell-legacy/grisette-core/src/Grisette/Core/Data/Class/Mergeable.hs) and [SimpleMergeable.hs](grisette-haskell-legacy/grisette-core/src/Grisette/Core/Data/Class/SimpleMergeable.hs) are for merging.
- [SOrd.hs](grisette-haskell-legacy/grisette-core/src/Grisette/Core/Data/Class/SOrd.hs) is for symbolic `Ord` type class. Symbolic `Eq` class is defined at [Bool.hs](grisette-haskell-legacy/grisette-core/src/Grisette/Core/Data/Class/Bool.hs)
- [ToCon.hs](grisette-haskell-legacy/grisette-core/src/Grisette/Core/Data/Class/ToCon.hs) and [ToSym.hs](grisette-haskell-legacy/grisette-core/src/Grisette/Core/Data/Class/ToSym.hs) provides the conversion between concrete and symbolic types.
- [Solver.hs](grisette-haskell-legacy/grisette-core/src/Grisette/Core/Data/Class/Solver.hs) contains the solver interfaces.

There are some Haddock documents, but they may be obsolete as the APIs are still quite unstable.
We will build the documents when Grisette is ready for release.

#### `grisette-symir`
We provide a symbolic primitive type implementation at the [grisette-symir](grisette-haskell-legacy/grisette-symir) package, which is based on SMTLIB2 language.
The user may design their own symbolic primitives with other techniques, e.g., BDDs, if appropriate for their tasks.

#### `grisette-backend-sbv`
This package contains our backend solver interface implemented using `sbv`.

#### `grisette-backend-direct`
In the future, this would be a package for an alternative backend directly talk to the solvers without external packages. Not available now.

#### `grisette-fused-effects`, `grisette-monad-coroutine`, `grisette-vector-sized`
Supporting some external libraries.
The support for bitvectors is built into `grisette-core`.

#### `grisette-benchmarks`
Implementation of the benchmark programs.

#### `grisette-unordered`
Implementation of the benchmark programs with MEG semantics.

#### `grisette-cbmcencoding`
Implementation of the benchmark programs with CBMC error encoding.

#### `grisette`
Aggregated package for `grisette-core`, `grisette-symir`, `grisette-lib` and `grisette-sbv`.

#### `grisette-examples`
Contains some examples we built during our development. Some of them are obsolete.

You can checkout `expr-interpreter` for a type system verifier for a simple expression language, `expr-sketch` for a synthesizer for a simple expression language, and `stmt-sketch` for a synthesizer for a statement language with program states.

These files may give you an idea of how a symbolic compiler would be constructed in Grisette. 

`tutorial` folder contains an introduction to the basic interfaces of Grisette. (caveat: this is not maintained for a long time).

#### Other `grisette-*` folders
Other folders contains the files used during our development, may be obsolete.


